# **Как ветвления и неуместные классы заслонили ясность машин состояний и породили сложности в коде**  

Программирование могло бы быть **чистым, предсказуемым и модульным**, если бы не две роковые ошибки:  

1. **Злоупотребление ветвлениями (`if/else`), которые превратили логику в лабиринт неочевидных переходов.  
2. **Неуместное использование классов**, когда вместо простых функций с явными зависимостями создаются громоздкие объекты, скрывающие состояние и усложняющие поток данных.  

В результате **машины состояний (FSM) оказались забыты**, а код превратился в **спагетти-логику**, где ошибки плодятся быстрее, чем их успевают исправлять.  

---  

## **1. Ветвления — это топор вместо скальпеля**  

Когда программист видит задачу, его первая мысль: *"Накидаю `if`-ов, и всё заработает!"*  

```python
def process_request(request):
    if request.method == "GET":
        if request.user.is_authenticated:
            if request.path == "/dashboard":
                return render_dashboard(request.user)
            elif request.path == "/profile":
                if request.user.has_permission("view_profile"):
                    return render_profile(request.user)
                else:
                    return error_403()
            # ... и ещё 20 вложенных условий
        else:
            return redirect_to_login()
    elif request.method == "POST":
        # ... ещё больше ветвлений
```  

### **Что не так?**  
- **Код становится нечитаемым** — понять логику можно, только мысленно симулируя все условия.  
- **Сложно поддерживать** — добавление новой фичи требует вписывания ещё одного `if`, что увеличивает энтропию.  
- **Ошибки ускользают** — где-то пропущена проверка, и система ломается в неожиданный момент.  

**Машины состояний решают это явным моделированием переходов:**  
```python
def handle_request(state, request):
    match (state, request.method, request.path):
        case (State.UNAUTHENTICATED, "GET", _):
            return redirect_to_login()
        case (State.AUTHENTICATED, "GET", "/dashboard"):
            return render_dashboard()
        case (State.AUTHENTICATED, "GET", "/profile") if user.can_view_profile():
            return render_profile()
        # ... все переходы видны сразу
```  
**Нет неочевидных ветвлений — есть чёткие правила перехода.**  

---  

## **2. Классы вместо функций: ненужная сложность**  

Второе проклятие современного кода — **использование классов там, где хватило бы функций**.  

### **Плохо: Класс, который скрывает состояние и зависимости**  
```python
class UserProfileRenderer:
    def __init__(self, user, db_connection, config):
        self.user = user
        self.db = db_connection
        self.config = config

    def render(self):
        if self.user.is_active:
            profile = self.db.get_profile(self.user.id)
            return f"<h1>{profile.name}</h1>"
        else:
            raise ValueError("User inactive")
```  

**Проблемы:**  
- **Состояние (`user`, `db`, `config`) привязано к экземпляру**, хотя могло быть передано явно.  
- **Тестирование сложнее** — нужно мокать весь класс, а не просто проверить функцию.  
- **Избыточность** — если метод использует только `user`, зачем тащить `db` и `config`?  

### **Лучше: Чистая функция с явными зависимостями**  
```python
def render_user_profile(user: User, fetch_profile: Callable[[int], Profile]):
    if not user.is_active:
        raise ValueError("User inactive")
    profile = fetch_profile(user.id)
    return f"<h1>{profile.name}</h1>"
```  

**Почему так лучше?**  
- **Явные зависимости** — сразу видно, что нужно для работы.  
- **Легко тестировать** — можно подменить `fetch_profile` заглушкой.  
- **Нет скрытого состояния** — функция детерминирована.  

---  

## **3. Как вернуть порядок? FSM + Функциональный стиль**  

### **Решение 1: Заменить ветвления на машины состояний**  
- Использовать `match/case` (Python), `switch` (JS/TS), библиотеки вроде `xstate`.  
- Явно описывать переходы, а не прятать их в `if`.  

### **Решение 2: Передавать зависимости в функции, а не прятать в классах**  
- **Функции > Классы**, когда состояние не нужно хранить.  
- **Явная передача данных > Неявный `this`/`self`.**  

### **Итог: Чистый, тестируемый, предсказуемый код**  
Вместо:  
```python
if (A) {
    if (B) {
        for (C in D) {
            if (E) { ... }
        }
    }
}
```  

Стало:  
```python
match (state, event):
    case (State.A, Event.B): ... 
    case (State.C, Event.D): ...
```  

---  

## **Вывод**  
**Ветвления и избыточные классы — это костыли, которые мешают писать ясный код.**  

- **Машины состояний** делают логику **предсказуемой**.  
- **Функции с явными зависимостями** делают код **понятным и тестируемым**.  

Пора перестать писать **хаотичные `if`-ы** и **раздутые классы** и вернуться к **чистым, управляемым решениям**.